/* tslint:disable */

import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { Observable } from 'rxjs';
import { HttpOptions } from './';

import * as models from './models';

export const USE_DOMAIN = new InjectionToken<string>('USE_DOMAIN');
export const USE_HTTP_OPTIONS = new InjectionToken<HttpOptions>('USE_HTTP_OPTIONS');

/**
 * Created with https://github.com/flowup/api-client-generator
 */
@Injectable()
export class APIClient {

  readonly options: HttpOptions;
  private domain: string = `//${window.location.hostname}${window.location.port ? ':'+window.location.port : ''}/god-api/`;

  constructor(private http: HttpClient,
              @Optional() @Inject(USE_DOMAIN) domain: string,
              @Optional() @Inject(USE_HTTP_OPTIONS) options: HttpOptions) {

    if (domain) {
      this.domain = domain;
    }

    this.options = {
      headers: options && options.headers ? options.headers : new HttpHeaders(),
      params: options && options.params ? options.params : new HttpParams(),
      ...(options && options.reportProgress ? { reportProgress: options.reportProgress } : {}),
      ...(options && options.withCredentials ? { withCredentials: options.withCredentials } : {})
    };
  }

  postAdminAuthenticate(
    args: {
      username: string,
      password: string,
    },
    options?: HttpOptions
  ): Observable<any> {
    const path = `/admin_login`;
    options = {...this.options, ...options};

    return this.sendRequest<any>('POST', path, options, JSON.stringify(args.username), JSON.stringify(args.password));
  }

  postUserAuthenticate(
    args: {
      email: string,
      password: string,
    },
    options?: HttpOptions
  ): Observable<any> {
    const path = `/user_login`;
    options = {...this.options, ...options};

    return this.sendRequest<any>('POST', path, options, JSON.stringify(args.email), JSON.stringify(args.password));
  }

  getAdministratorCollection(
    args: {
      username?: string,
      pass?: string,
      email?: string,
      name?: string,
      lastname?: string,
      brand?: string,
      company?: string,
      timezone?: string,
      active?: boolean,
      order[username]?: string,
      order[pass]?: string,
      order[email]?: string,
      order[active]?: string,
      order[name]?: string,
      order[lastname]?: string,
      page?: number,
      itemsPerPage?: number,
    },
    options?: HttpOptions
  ): Observable<models.AdministratorCollection[]> {
    const path = `/administrators`;
    options = {...this.options, ...options};

    if ('username' in args) {
      options.params = options.params.set('username', String(args.username));
    }
    if ('pass' in args) {
      options.params = options.params.set('pass', String(args.pass));
    }
    if ('email' in args) {
      options.params = options.params.set('email', String(args.email));
    }
    if ('name' in args) {
      options.params = options.params.set('name', String(args.name));
    }
    if ('lastname' in args) {
      options.params = options.params.set('lastname', String(args.lastname));
    }
    if ('brand' in args) {
      options.params = options.params.set('brand', String(args.brand));
    }
    if ('company' in args) {
      options.params = options.params.set('company', String(args.company));
    }
    if ('timezone' in args) {
      options.params = options.params.set('timezone', String(args.timezone));
    }
    if ('active' in args) {
      options.params = options.params.set('active', String(args.active));
    }
    if ('order[username]' in args) {
      options.params = options.params.set('_order[username]', String(args.order[username]));
    }
    if ('order[pass]' in args) {
      options.params = options.params.set('_order[pass]', String(args.order[pass]));
    }
    if ('order[email]' in args) {
      options.params = options.params.set('_order[email]', String(args.order[email]));
    }
    if ('order[active]' in args) {
      options.params = options.params.set('_order[active]', String(args.order[active]));
    }
    if ('order[name]' in args) {
      options.params = options.params.set('_order[name]', String(args.order[name]));
    }
    if ('order[lastname]' in args) {
      options.params = options.params.set('_order[lastname]', String(args.order[lastname]));
    }
    if ('page' in args) {
      options.params = options.params.set('_page', String(args.page));
    }
    if ('itemsPerPage' in args) {
      options.params = options.params.set('_itemsPerPage', String(args.itemsPerPage));
    }
    return this.sendRequest<models.AdministratorCollection[]>('GET', path, options);
  }

  postAdministratorCollection(
    args: {
      administrator?: models.Administrator,
    },
    options?: HttpOptions
  ): Observable<any> {
    const path = `/administrators`;
    options = {...this.options, ...options};

    return this.sendRequest<any>('POST', path, options, JSON.stringify(args.administrator));
  }

  getAdministratorItem(
    args: {
      id: string,
    },
    options?: HttpOptions
  ): Observable<models.AdministratorDetailed> {
    const path = `/administrators/${args.id}`;
    options = {...this.options, ...options};

    return this.sendRequest<models.AdministratorDetailed>('GET', path, options);
  }

  putAdministratorItem(
    args: {
      id: string,
      administrator?: models.Administrator,
    },
    options?: HttpOptions
  ): Observable<models.Administrator> {
    const path = `/administrators/${args.id}`;
    options = {...this.options, ...options};

    return this.sendRequest<models.Administrator>('PUT', path, options, JSON.stringify(args.administrator));
  }

  deleteAdministratorItem(
    args: {
      id: string,
    },
    options?: HttpOptions
  ): Observable<any> {
    const path = `/administrators/${args.id}`;
    options = {...this.options, ...options};

    return this.sendRequest<any>('DELETE', path, options);
  }

  getApplicationServerCollection(
    args: {
      ip?: string,
      name?: string,
      order[ip]?: string,
      order[name]?: string,
      page?: number,
      itemsPerPage?: number,
    },
    options?: HttpOptions
  ): Observable<models.ApplicationServerCollection[]> {
    const path = `/application_servers`;
    options = {...this.options, ...options};

    if ('ip' in args) {
      options.params = options.params.set('ip', String(args.ip));
    }
    if ('name' in args) {
      options.params = options.params.set('name', String(args.name));
    }
    if ('order[ip]' in args) {
      options.params = options.params.set('_order[ip]', String(args.order[ip]));
    }
    if ('order[name]' in args) {
      options.params = options.params.set('_order[name]', String(args.order[name]));
    }
    if ('page' in args) {
      options.params = options.params.set('_page', String(args.page));
    }
    if ('itemsPerPage' in args) {
      options.params = options.params.set('_itemsPerPage', String(args.itemsPerPage));
    }
    return this.sendRequest<models.ApplicationServerCollection[]>('GET', path, options);
  }

  postApplicationServerCollection(
    args: {
      applicationServer?: models.ApplicationServer,
    },
    options?: HttpOptions
  ): Observable<any> {
    const path = `/application_servers`;
    options = {...this.options, ...options};

    return this.sendRequest<any>('POST', path, options, JSON.stringify(args.applicationServer));
  }

  getApplicationServerItem(
    args: {
      id: string,
    },
    options?: HttpOptions
  ): Observable<models.ApplicationServerDetailed> {
    const path = `/application_servers/${args.id}`;
    options = {...this.options, ...options};

    return this.sendRequest<models.ApplicationServerDetailed>('GET', path, options);
  }

  putApplicationServerItem(
    args: {
      id: string,
      applicationServer?: models.ApplicationServer,
    },
    options?: HttpOptions
  ): Observable<models.ApplicationServer> {
    const path = `/application_servers/${args.id}`;
    options = {...this.options, ...options};

    return this.sendRequest<models.ApplicationServer>('PUT', path, options, JSON.stringify(args.applicationServer));
  }

  deleteApplicationServerItem(
    args: {
      id: string,
    },
    options?: HttpOptions
  ): Observable<any> {
    const path = `/application_servers/${args.id}`;
    options = {...this.options, ...options};

    return this.sendRequest<any>('DELETE', path, options);
  }

  getBrandCollection(
    args: {
      name?: string,
      domainUsers?: string,
      recordingsLimitEmail?: string,
      domain?: string,
      language?: string,
      defaultTimezone?: string,
      recordingsLimitMB?: number,
      maxCalls?: number,
      recordingsLimitMB[between]?: string,
      recordingsLimitMB[gt]?: string,
      recordingsLimitMB[gte]?: string,
      recordingsLimitMB[lt]?: string,
      recordingsLimitMB[lte]?: string,
      maxCalls[between]?: string,
      maxCalls[gt]?: string,
      maxCalls[gte]?: string,
      maxCalls[lt]?: string,
      maxCalls[lte]?: string,
      order[name]?: string,
      order[domainUsers]?: string,
      order[recordingsLimitMB]?: string,
      order[recordingsLimitEmail]?: string,
      order[maxCalls]?: string,
      page?: number,
      itemsPerPage?: number,
    },
    options?: HttpOptions
  ): Observable<models.BrandCollection[]> {
    const path = `/brands`;
    options = {...this.options, ...options};

    if ('name' in args) {
      options.params = options.params.set('name', String(args.name));
    }
    if ('domainUsers' in args) {
      options.params = options.params.set('domainUsers', String(args.domainUsers));
    }
    if ('recordingsLimitEmail' in args) {
      options.params = options.params.set('recordingsLimitEmail', String(args.recordingsLimitEmail));
    }
    if ('domain' in args) {
      options.params = options.params.set('domain', String(args.domain));
    }
    if ('language' in args) {
      options.params = options.params.set('language', String(args.language));
    }
    if ('defaultTimezone' in args) {
      options.params = options.params.set('defaultTimezone', String(args.defaultTimezone));
    }
    if ('recordingsLimitMB' in args) {
      options.params = options.params.set('recordingsLimitMB', String(args.recordingsLimitMB));
    }
    if ('maxCalls' in args) {
      options.params = options.params.set('maxCalls', String(args.maxCalls));
    }
    if ('recordingsLimitMB[between]' in args) {
      options.params = options.params.set('recordingsLimitMB[between]', String(args.recordingsLimitMB[between]));
    }
    if ('recordingsLimitMB[gt]' in args) {
      options.params = options.params.set('recordingsLimitMB[gt]', String(args.recordingsLimitMB[gt]));
    }
    if ('recordingsLimitMB[gte]' in args) {
      options.params = options.params.set('recordingsLimitMB[gte]', String(args.recordingsLimitMB[gte]));
    }
    if ('recordingsLimitMB[lt]' in args) {
      options.params = options.params.set('recordingsLimitMB[lt]', String(args.recordingsLimitMB[lt]));
    }
    if ('recordingsLimitMB[lte]' in args) {
      options.params = options.params.set('recordingsLimitMB[lte]', String(args.recordingsLimitMB[lte]));
    }
    if ('maxCalls[between]' in args) {
      options.params = options.params.set('maxCalls[between]', String(args.maxCalls[between]));
    }
    if ('maxCalls[gt]' in args) {
      options.params = options.params.set('maxCalls[gt]', String(args.maxCalls[gt]));
    }
    if ('maxCalls[gte]' in args) {
      options.params = options.params.set('maxCalls[gte]', String(args.maxCalls[gte]));
    }
    if ('maxCalls[lt]' in args) {
      options.params = options.params.set('maxCalls[lt]', String(args.maxCalls[lt]));
    }
    if ('maxCalls[lte]' in args) {
      options.params = options.params.set('maxCalls[lte]', String(args.maxCalls[lte]));
    }
    if ('order[name]' in args) {
      options.params = options.params.set('_order[name]', String(args.order[name]));
    }
    if ('order[domainUsers]' in args) {
      options.params = options.params.set('_order[domainUsers]', String(args.order[domainUsers]));
    }
    if ('order[recordingsLimitMB]' in args) {
      options.params = options.params.set('_order[recordingsLimitMB]', String(args.order[recordingsLimitMB]));
    }
    if ('order[recordingsLimitEmail]' in args) {
      options.params = options.params.set('_order[recordingsLimitEmail]', String(args.order[recordingsLimitEmail]));
    }
    if ('order[maxCalls]' in args) {
      options.params = options.params.set('_order[maxCalls]', String(args.order[maxCalls]));
    }
    if ('page' in args) {
      options.params = options.params.set('_page', String(args.page));
    }
    if ('itemsPerPage' in args) {
      options.params = options.params.set('_itemsPerPage', String(args.itemsPerPage));
    }
    return this.sendRequest<models.BrandCollection[]>('GET', path, options);
  }

  postBrandCollection(
    args: {
      brand?: models.Brand,
    },
    options?: HttpOptions
  ): Observable<any> {
    const path = `/brands`;
    options = {...this.options, ...options};

    return this.sendRequest<any>('POST', path, options, JSON.stringify(args.brand));
  }

  getBrandItem(
    args: {
      id: string,
    },
    options?: HttpOptions
  ): Observable<models.BrandDetailed> {
    const path = `/brands/${args.id}`;
    options = {...this.options, ...options};

    return this.sendRequest<models.BrandDetailed>('GET', path, options);
  }

  putBrandItem(
    args: {
      id: string,
      brand?: models.Brand,
    },
    options?: HttpOptions
  ): Observable<models.Brand> {
    const path = `/brands/${args.id}`;
    options = {...this.options, ...options};

    return this.sendRequest<models.Brand>('PUT', path, options, JSON.stringify(args.brand));
  }

  deleteBrandItem(
    args: {
      id: string,
    },
    options?: HttpOptions
  ): Observable<any> {
    const path = `/brands/${args.id}`;
    options = {...this.options, ...options};

    return this.sendRequest<any>('DELETE', path, options);
  }

  private sendRequest<T>(method: string, path: string, options: HttpOptions, body?: any): Observable<T> {
    switch (method) {
      case 'DELETE':
        return this.http.delete<T>(`${this.domain}${path}`, options);
      case 'GET':
        return this.http.get<T>(`${this.domain}${path}`, options);
      case 'HEAD':
        return this.http.head<T>(`${this.domain}${path}`, options);
      case 'OPTIONS':
        return this.http.options<T>(`${this.domain}${path}`, options);
      case 'PATCH':
        return this.http.patch<T>(`${this.domain}${path}`, body, options);
      case 'POST':
        return this.http.post<T>(`${this.domain}${path}`, body, options);
      case 'PUT':
        return this.http.put<T>(`${this.domain}${path}`, body, options);
      default:
        console.error(`Unsupported request: ${method}`);
        return Observable.throw(`Unsupported request: ${method}`);
    }
  }
}
